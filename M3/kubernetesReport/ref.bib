%% This BibTeX bibliography file was created using BibDesk.
%% https://bibdesk.sourceforge.io/



@misc{clark_jdepend_2023,
	title = {{JDepend}},
	copyright = {MIT},
	url = {https://github.com/clarkware/jdepend},
	abstract = {A Java package dependency analyzer that generates design quality metrics.},
	urldate = {2023-03-20},
	author = {Clark, Mike},
	month = mar,
	year = {2023},
	note = {original-date: 2008-08-21T21:34:50Z},
}

@misc{the_linux_foundation_secrets_2024,
	title = {Secrets},
	url = {https://kubernetes.io/docs/concepts/configuration/secret/},
	abstract = {A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a Pod specification or in a container image. Using a Secret means that you don't need to include confidential data in your application code.
	Because Secrets can be created independently of the Pods that use them, there is less risk of the Secret (and its data) being exposed during the workflow of creating, viewing, and editing Pods.},
	language = {en},
	urldate = {2024-11-17},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs}
}


@misc{the_linux_foundation_encrypting_2024,
	title = {Encrypting {Confidential} {Data} at {Rest}},
	url = {https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/},
	abstract = {All of the APIs in Kubernetes that let you write persistent API resource data support at-rest encryption. For example, you can enable at-rest encryption for Secrets. This at-rest encryption is additional to any system-level encryption for the etcd cluster or for the filesystem(s) on hosts where you are running the kube-apiserver.
	This page shows how to enable and configure encryption of API data at rest.
	Note:This task covers encryption for resource data stored using the Kubernetes API.},
	language = {en},
	urldate = {2024-11-17},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs}
}


@book{gkatziouras_kubernetes_2024,
	address = {Place of publication not identified},
	title = {Kubernetes secrets handbook: design, implement, and maintain production-grade {Kubernetes} {Secrets} management solutions},
	isbn = {978-1-80512-322-4 978-1-80512-715-4},
	shorttitle = {Kubernetes secrets handbook},
	abstract = {Gain hands-on skills in Kubernetes Secrets management, ensuring a comprehensive overview of the Secrets lifecycle and prioritizing adherence to regulatory standards and business sustainability Key Features Master Secrets encryption, encompassing complex life cycles, key rotation, access control, backup, and recovery Build your skills to audit Secrets consumption, troubleshoot, and optimize for efficiency and compliance Learn how to manage Secrets through real-world cases, strengthening your applications' security posture Purchase of the print or Kindle book includes a free PDF eBook Book Description Securing Secrets in containerized apps poses a significant challenge for Kubernetes IT professionals. This book tackles the critical task of safeguarding sensitive data, addressing the limitations of Kubernetes encryption, and establishing a robust Secrets management system for heightened security for Kubernetes. Starting with the fundamental Kubernetes architecture principles and how they apply to the design of Secrets management, this book delves into advanced Kubernetes concepts such as hands-on security, compliance, risk mitigation, disaster recovery, and backup strategies. With the help of practical, real-world guidance, you'll learn how to mitigate risks and establish robust Secrets management as you explore different types of external secret stores, configure them in Kubernetes, and integrate them with existing Secrets management solutions. Further, you'll design, implement, and operate a secure method of managing sensitive payload by leveraging real use cases in an iterative process to enhance skills, practices, and analytical thinking, progressively strengthening the security posture with each solution. By the end of this book, you'll have a rock-solid Secrets management solution to run your business-critical applications in a hybrid multi-cloud scenario, addressing operational risks, compliance, and controls. What you will learn Explore Kubernetes Secrets, related API objects, and CRUD operations Understand the Kubernetes Secrets limitations, attack vectors, and mitigation strategies Explore encryption at rest and external secret stores Build and operate a production-grade solution with a focus on business continuity Integrate a Secrets Management solution in your CI/CD pipelines Conduct continuous assessments of the risks and vulnerabilities for each solution Draw insights from use cases implemented by large organizations Gain an overview of the latest and upcoming Secrets management trends Who this book is for This handbook is a comprehensive reference for IT professionals to design, implement, operate, and audit Secrets in applications and platforms running on Kubernetes. For developer, platform, and security teams experienced with containers, this Secrets management guide offers a progressive path--from foundations to implementation--with a security-first mindset. You'll also find this book useful if you work with hybrid multi-cloud Kubernetes platforms for organizations concerned with governance and compliance requirements},
	language = {en},
	publisher = {Packt Publishing},
	author = {Gkatziouras, Emmanouil and Adams, Rom and Xi, Chen and Jenkins, Chris},
	year = {2024},
	file = {PDF:/home/luis/Zotero/storage/PPA24XE5/Gkatziouras et al. - 2024 - Kubernetes secrets handbook design, implement, and maintain production-grade Kubernetes Secrets man.pdf:application/pdf},
}


@misc{the_linux_foundation_authenticating_2024,
	title = {Authenticating},
	url = {https://kubernetes.io/docs/reference/access-authn-authz/authentication/},
	abstract = {This page provides an overview of authentication.
	Users in Kubernetes All Kubernetes clusters have two categories of users: service accounts managed by Kubernetes, and normal users.
	It is assumed that a cluster-independent service manages normal users in the following ways:
	an administrator distributing private keys a user store like Keystone or Google Accounts a file with a list of usernames and passwords In this regard, Kubernetes does not have objects which represent normal user accounts.},
	language = {en},
	urldate = {2024-11-17},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/6G7ADPQA/authentication.html:text/html},
}

@misc{the_linux_foundation_generate_2024,
	title = {Generate {Certificates} {Manually}},
	url = {https://kubernetes.io/docs/tasks/administer-cluster/certificates/},
	abstract = {When using client certificate authentication, you can generate certificates manually through easyrsa, openssl or cfssl.
	easyrsa easyrsa can manually generate certificates for your cluster.
	Download, unpack, and initialize the patched version of easyrsa3.
	curl -LO https://dl.k8s.io/easy-rsa/easy-rsa.tar.gz tar xzf easy-rsa.tar.gz cd easy-rsa-master/easyrsa3 ./easyrsa init-pki Generate a new certificate authority (CA). --batch sets automatic mode; --req-cn specifies the Common Name (CN) for the CA's new root certificate.
	./easyrsa --batch "--req-cn=\$\{MASTER\_IP\}@`date +\%s`" build-ca nopass Generate server certificate and key.},
	language = {en},
	urldate = {2024-11-26},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/S95PXB4C/certificates.html:text/html},
}


@misc{the_linux_foundation_kubernetes_2024,
	title = {Kubernetes Components},
	url = {https://kubernetes.io/docs/concepts/overview/components/},
	titleaddon = {Kubernetes Components},
	author = {{The Linux Foundation}},
}

@misc{etcd_faq_2024,
	title = {{FAQ}},
	url = {https://etcd.io/docs/v3.6/faq/},
	abstract = {Frequently asked questions},
	titleaddon = {etcd},
	author = {{etcd}},
	urldate = {2024-11-28},
	langid = {english},
	note = {Section: docs},
	file = {Snapshot:files/40/faq.html:text/html},
}


@misc{the_linux_foundation_controlling_2023,
	title = {Controlling {Access} to the {Kubernetes} {API}},
	url = {https://kubernetes.io/docs/concepts/security/controlling-access/},
	abstract = {This page provides an overview of controlling access to the Kubernetes API.
	Users access the Kubernetes API using kubectl, client libraries, or by making REST requests. Both human users and Kubernetes service accounts can be authorized for API access. When a request reaches the API, it goes through several stages, illustrated in the following diagram:
	Transport security By default, the Kubernetes API server listens on port 6443 on the first non-localhost network interface, protected by TLS.},
	language = {en},
	urldate = {2024-12-07},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2023},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/MPC65RLA/controlling-access.html:text/html},
}


@misc{the_linux_foundation_admission_2024,
	title = {Admission {Control} in {Kubernetes}},
	url = {https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/},
	abstract = {This page provides an overview of admission controllers.
	An admission controller is a piece of code that intercepts requests to the Kubernetes API server prior to persistence of the resource, but after the request is authenticated and authorized.
	Several important features of Kubernetes require an admission controller to be enabled in order to properly support the feature. As a result, a Kubernetes API server that is not properly configured with the right set of admission controllers is an incomplete server that will not support all the features you expect.},
	language = {en},
	urldate = {2024-12-08},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/8TID97JK/admission-controllers.html:text/html},
}


@book{sayfan_mastering_2020,
	address = {Place of publication not identified},
	edition = {3rd ed},
	title = {Mastering {Kubernetes}: level up your container orchestration skills with {Kubernetes} to build, run, secure, and observe largescale distributed apps, third edition},
	isbn = {978-1-83921-125-6 978-1-83921-308-3},
	shorttitle = {Mastering {Kubernetes}},
	abstract = {Master Kubernetes architecture and design to build and deploy secure distributed applications Learn advanced concepts like autoscaling, cluster federation, serverless computing, and service mesh integration for observability Explore Kubernetes 1.18 features and its rich ecosystem of tools like Kubectl, Knative, and Helm Book DescriptionThe third edition of Mastering Kubernetes is updated with the latest tools and code enabling you to learn Kubernetes 1.18's latest features. This book primarily concentrates on diving deeply into complex concepts and Kubernetes best practices to help you master the skills of designing and deploying large clusters on various cloud platforms. The book trains you to run complex stateful microservices on Kubernetes including advanced features such as horizontal pod autoscaling, rolling updates, resource quotas, and persistent storage backend. With the two new chapters, you will gain expertise in serverless computing and utilizing service meshes. As you proceed through the chapters, you will explore different options for network configuration and learn to set up, operate, and troubleshoot Kubernetes networking plugins through real-world use cases. Furthermore, you will understand the mechanisms of custom resource development and its utilization in automation and maintenance workflows. By the end of this Kubernetes book, you will graduate from an intermediate to advanced Kubernetes professional},
	language = {en},
	publisher = {Packt Publishing},
	author = {Sayfan, Gigi},
	year = {2020},
	file = {PDF:/home/luis/Zotero/storage/UM5EKTBU/Sayfan - 2020 - Mastering Kubernetes level up your container orchestration skills with Kubernetes to build, run, se.pdf:application/pdf},
}


@book{martin_hacking_2021,
	address = {Sebastopol},
	title = {Hacking kubernetes: threat-driven analysis and defense},
	isbn = {978-1-4920-8173-9 978-1-4920-8170-8},
	shorttitle = {Hacking kubernetes},
	language = {eng},
	publisher = {O'Reilly Media, Incorporated},
	author = {Martin, Andrew and Hausenblas, Michael},
	year = {2021},
	annote = {Description based on publisher supplied metadata and other sources},
	file = {PDF:/home/luis/Zotero/storage/LA58SLMY/Martin and Hausenblas - Hacking Kubernetes.pdf:application/pdf},
}


@misc{the_linux_foundation_webhook_2024,
	title = {Webhook {Mode}},
	url = {https://kubernetes.io/docs/reference/access-authn-authz/webhook/},
	abstract = {A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen.
	When specified, mode Webhook causes Kubernetes to query an outside REST service when determining user privileges.
	Configuration File Format Mode Webhook requires a file for HTTP configuration, specify by the --authorization-webhook-config-file=SOME\_FILENAME flag.
	The configuration file uses the kubeconfig file format.},
	language = {en},
	urldate = {2024-12-08},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/MPVU7DNY/webhook.html:text/html},
}


@misc{eknert_kubernetes_2022,
	title = {The {Kubernetes} {Authorization} {Webhook}},
	url = {https://www.styra.com/blog/kubernetes-authorization-webhook/},
	abstract = {Kubernetes Authorization webhook offers a powerful mechanism to extend the modules that comprise the K8s API servers with custom code for authorization.},
	language = {en-US},
	urldate = {2024-12-08},
	journal = {Styra},
	author = {Eknert, Anders},
	month = may,
	year = {2022},
	file = {Snapshot:/home/luis/Zotero/storage/LS9MEJ5C/kubernetes-authorization-webhook.html:text/html},
}


@article{national_security_agency_kubernetes_2022,
	title = {Kubernetes {Hardening} {Guide}},
	url = {https://media.defense.gov/2022/Aug/29/2003066362/-1/-1/0/CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.PDF},
	abstract = {NSA and CISA developed this document in furtherance of their respective cybersecurity missions, including their responsibilities to develop and issue cybersecurity specifications and mitigations. This information may be shared broadly to reach all appropriate stakeholders.},
	journal = {Cybersecurity Technical Report},
	author = {{National Security Agency} and {Cybersecurity and Infrastructure Security Agency}},
	year = {2022},
	file = {CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.pdf:/home/luis/Zotero/storage/BDMGVWXW/CTR_KUBERNETES_HARDENING_GUIDANCE_1.2_20220829.pdf:application/pdf},
}


@misc{the_linux_foundation_resource_2024,
	title = {Resource {Quotas}},
	url = {https://kubernetes.io/docs/concepts/policy/resource-quotas/},
	abstract = {When several users or teams share a cluster with a fixed number of nodes, there is a concern that one team could use more than its fair share of resources.
	Resource quotas are a tool for administrators to address this concern.
	A resource quota, defined by a ResourceQuota object, provides constraints that limit aggregate resource consumption per namespace. It can limit the quantity of objects that can be created in a namespace by type, as well as the total amount of compute resources that may be consumed by resources in that namespace.},
	language = {en},
	urldate = {2024-12-08},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/CB949S37/resource-quotas.html:text/html},
}


@misc{the_linux_foundation_limit_2024,
	title = {Limit {Ranges}},
	url = {https://kubernetes.io/docs/concepts/policy/limit-range/},
	abstract = {By default, containers run with unbounded compute resources on a Kubernetes cluster. Using Kubernetes resource quotas, administrators (also termed cluster operators) can restrict consumption and creation of cluster resources (such as CPU time, memory, and persistent storage) within a specified namespace. Within a namespace, a Pod can consume as much CPU and memory as is allowed by the ResourceQuotas that apply to that namespace. As a cluster operator, or as a namespace-level administrator, you might also be concerned about making sure that a single object cannot monopolize all available resources within a namespace.},
	language = {en},
	urldate = {2024-12-08},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/7FBY2EWL/limit-range.html:text/html},
}


@misc{national_institute_of_standards_and_technology_nvd_2020,
	title = {{NVD} - cve-2020-8558},
	url = {https://nvd.nist.gov/vuln/detail/cve-2020-8558},
	urldate = {2024-12-14},
	author = {{National Institute of Standards and Technology}},
	month = jul,
	year = {2020},
	file = {NVD - cve-2020-8558:/home/luis/Zotero/storage/DV8XWYAW/cve-2020-8558.html:text/html},
}


@misc{the_linux_foundation_kube-apiserver_2024,
	title = {kube-apiserver},
	url = {https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/},
	abstract = {Synopsis The Kubernetes API server validates and configures data for the api objects which include pods, services, replicationcontrollers, and others. The API Server services REST operations and provides the frontend to the cluster's shared state through which all other components interact.
	kube-apiserver [flags] Options --admission-control-config-file string File with admission control configuration.
	--advertise-address string The IP address on which to advertise the apiserver to members of the cluster. This address must be reachable by the rest of the cluster.},
	language = {en},
	urldate = {2024-12-14},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/XDWI389M/kube-apiserver.html:text/html},
}


@misc{the_linux_foundation_auditing_2024,
	title = {Auditing},
	url = {https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/},
	abstract = {Kubernetes auditing provides a security-relevant, chronological set of records documenting the sequence of actions in a cluster. The cluster audits the activities generated by users, by applications that use the Kubernetes API, and by the control plane itself.
	Auditing allows cluster administrators to answer the following questions:
	what happened? when did it happen? who initiated it? on what did it happen? where was it observed? from where was it initiated?},
	language = {en},
	urldate = {2024-11-28},
	journal = {Kubernetes},
	author = {{The Linux Foundation}},
	year = {2024},
	note = {Section: docs},
	file = {Snapshot:/home/luis/Zotero/storage/Q7JNJ25J/audit.html:text/html},
}

@article{rostami_role-based_2023,
	title = {Role-{Based} {Access} {Control} ({RBAC}) {Authorization} in {Kubernetes}},
	volume = {11},
	issn = {2246-0853},
	url = {https://ieeexplore.ieee.org/document/10255393/?arnumber=10255393},
	doi = {10.13052/jicts2245-800X.1132},
	abstract = {In computer systems security, role-based access control (RBAC) or role-based security is an approach to restricting system access to authorized users [1]. This paper will describe how the Kubernetes RBAC authorization sub-system works, how to leverage it to secure access to resources in the cluster, and how to validate the set policies through impersonation to ensure users and service accounts are granted the intended rights.},
	number = {3},
	urldate = {2024-12-20},
	journal = {Journal of ICT Standardization},
	author = {Rostami, Garsha},
	year = {2023},
	note = {Conference Name: Journal of ICT Standardization},
	keywords = {Aerospace electronics, Authorization, Computer architecture, Computer security, Databases, Kubernetes aggregationRule, Kubernetes API groups, Kubernetes authorization, Kubernetes Cluster-RoleBinding, Kubernetes ClusterRole, Kubernetes impersonation, Kubernetes Role, Kubernetes Role-based Access Control, Kubernetes RoleBinding, Load management, RBAC, Standards},
	pages = {237--260},
	file = {Full Text PDF:C\:\\Users\\torre\\Zotero\\storage\\E53FP8BP\\Rostami - 2023 - Role-Based Access Control (RBAC) Authorization in Kubernetes.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\torre\\Zotero\\storage\\QSVG39G9\\10255393.html:text/html},
}

@misc{the_linux_foundation_rbacauthorization_2024,
	title = {Using {RBAC} {Authorization}},
	url = {https://kubernetes.io/docs/reference/access-authn-authz/rbac/},
	abstract = {Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.
	RBAC authorization uses the rbac.authorization.k8s.io API group to drive authorization decisions, allowing you to dynamically configure policies through the Kubernetes API.
	To enable RBAC, start the API server with the --authorization-config flag set to a file that includes the RBAC authorizer; for example:
	apiVersion: apiserver.},
	language = {en},
	urldate = {2024-12-22},
	journal = {Kubernetes},
	note = {Section: docs},
	file = {Snapshot:C\:\\Users\\torre\\Zotero\\storage\\HBYE54RX\\rbac.html:text/html},
}

@misc{network_policies_kubernetes_from_kubernetes_io,
	title = {Network {Policies}},
	url = {https://kubernetes.io/docs/concepts/services-networking/network-policies/},
	abstract = {If you want to control traffic flow at the IP address or port level (OSI layer 3 or 4), NetworkPolicies allow you to specify rules for traffic flow within your cluster, and also between Pods and the outside world. Your cluster must use a network plugin that supports NetworkPolicy enforcement.},
	language = {en},
	urldate = {2024-12-23},
	journal = {Kubernetes},
	note = {Section: docs},
	file = {Snapshot:/Users/pedrolemos/Zotero/storage/U9AE8WB9/network-policies.html:text/html},
}

@misc{amaechi_learn_2023,
	title = {Learn {Network} {Policies} in {Kubernetes}},
	url = {https://medium.com/cloud-native-daily/learn-network-policies-in-kubernetes-4b2258fe8572},
	abstract = {Understanding Kubernetes Network Policies: the fundamental concepts, syntax, semantics, and implementation considerations.},
	language = {en},
	urldate = {2024-12-24},
	journal = {Cloud Native Daily},
	author = {Amaechi, Sylvester},
	month = aug,
	year = {2023},
	file = {Snapshot:/Users/pedrolemos/Zotero/storage/B48AFLGR/learn-network-policies-in-kubernetes-4b2258fe8572.html:text/html},
}

@misc{walker_kubernetes_2023,
	title = {Kubernetes {Network} {Policy} - {Guide} with {Examples}},
	shorttitle = {Kubernetes {Network} {Policy}},
	url = {https://spacelift.io/blog/[slug]},
	abstract = {Learn what are Network Policies in Kubernetes, how to implement them and best practices. See examples for default policies, egress and ingress.},
	language = {en},
	urldate = {2024-12-26},
	journal = {Spacelift},
	author = {Walker, James},
	month = dec,
	year = {2023},
}

@misc{de_tender_kubernetes_2022,
	title = {Kubernetes network policy best practices},
	url = {https://snyk.io/pt-BR/blog/kubernetes-network-policy-best-practices/},
	abstract = {This article will explore Kubernetes NetworkPolicy by creating an example network policy and examining its core parameters. Then, we'll look at some common NetworkPolicy use cases and learn how to monitor them using kubectl. Finally, we'll discover how to implement Container Network Interface (CNI) using third-party Kubernetes extensions.},
	language = {pt-BR},
	urldate = {2024-12-26},
	journal = {Snyk},
	author = {De Tender, Peter},
	month = dec,
	year = {2022},
}
